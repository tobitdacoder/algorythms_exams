# -*- coding: utf-8 -*-
"""A98591_S22B23_001_Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OBieKrzhE1qCWVU65D7NXwh1AW66dC-Z
"""

# QUESTION TWO


import matplotlib.pyplot as plt
import timeit
import random

# Function to perform Selection Sort on an array
def selection_sort(arr):
    len_arr = len(arr)
    if len_arr <= 1:
        return arr
    else:
        for i in range(0, len_arr):
            min_ind = i
            for j in range(i + 1, len_arr):
                if arr[min_ind] > arr[j]:
                    min_ind = j
            arr[min_ind], arr[i] = arr[i], arr[min_ind]
    return arr


"""
We already know that the time complexity of the Selection Sort algorithm can be described as
O(n^2), where 'n' represents the number of the elements inside the input array.
This quadratic time complexity arises from the algorithm's nested iteration
structure. For each element in the array, Selection Sort potentially requires
scanning through the remaining unsorted elements, resulting in #n * (n-1) / 2#
comparisons and swaps in the worst-case scenario. As the input size increases,
the time taken grows quadratically, making it less efficient compared
to algorithms with better complexities for larger datasets.

"""

##################################################################################################################################################



def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[0]  # Select the first element as the pivot
        lesser = [x for x in arr[1:] if x <= pivot]  # Elements smaller than or equal to pivot
        greater = [x for x in arr[1:] if x > pivot]  # Elements greater than pivot
        return quick_sort(lesser) + [pivot] + quick_sort(greater)

input_sizes = [10000, 20000, 30000, 40000, 50000]  # Larger input sizes
time_taken_selection = []  # List to store the time taken by Selection Sort
time_taken_quick = []  # List to store the time taken by Quick Sort

for size in input_sizes:
    # Generate a random array of size 'size'
    arr_selection = [random.randint(1, 1000000) for _ in range(size)]
    arr_quick = arr_selection.copy()  # Create a copy for Quick Sort

    # Measure the time taken for Selection Sort
    start_time_selection = timeit.default_timer()
    selection_sort(arr_selection)
    end_time_selection = timeit.default_timer()
    time_taken_selection.append(end_time_selection - start_time_selection)

    # Measure the time taken for Quick Sort
    start_time_quick = timeit.default_timer()
    quick_sort(arr_quick)
    end_time_quick = timeit.default_timer()
    time_taken_quick.append(end_time_quick - start_time_quick)

# Plotting the graph for both algorithms
plt.plot(input_sizes, time_taken_selection, marker='o', label='Selection Sort')
plt.plot(input_sizes, time_taken_quick, marker='o', label='Quick Sort')
plt.title('Selection Sort vs Quick Sort Time Complexity Comparison')
plt.xlabel('Input Size (n)')
plt.ylabel('Time Taken')
plt.legend()  # Show legend
plt.grid(True)
plt.show()
